{"version":3,"sources":["../node_modules/codemirror/mode/twig/twig.js","../node_modules/codemirror/addon/mode/multiplex.js"],"names":["CodeMirror","defineMode","keywords","operator","sign","atom","number","RegExp","join","startState","token","stream","state","ch","peek","incomment","skipTo","eatWhile","skipToEnd","intag","match","instring","next","eat","sol","tokenBase","config","parserConfig","twigInner","getMode","base","multiplexingMode","open","close","mode","parseDelimiters","defineMIME","mod","__webpack_require__","outer","others","Array","prototype","slice","call","arguments","indexOf","string","pattern","from","returnEnd","found","length","m","exec","index","innerActive","inner","startingInner","copyState","curInner","oldContent","this","pos","delimStyle","innerToken","start","innerStyle","cutOff","Infinity","i","other","outerIndent","indent","possibleOuterIndent","Pass","outerToken","textAfter","line","blankLine","electricChars","innerMode"],"mappings":"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","file":"static/js/18.448d0cf1.chunk.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../../addon/mode/multiplex\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../../addon/mode/multiplex\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"twig:inner\", function () {\n    var keywords = [\"and\", \"as\", \"autoescape\", \"endautoescape\", \"block\", \"do\", \"endblock\", \"else\", \"elseif\", \"extends\", \"for\", \"endfor\", \"embed\", \"endembed\", \"filter\", \"endfilter\", \"flush\", \"from\", \"if\", \"endif\", \"in\", \"is\", \"include\", \"import\", \"not\", \"or\", \"set\", \"spaceless\", \"endspaceless\", \"with\", \"endwith\", \"trans\", \"endtrans\", \"blocktrans\", \"endblocktrans\", \"macro\", \"endmacro\", \"use\", \"verbatim\", \"endverbatim\"],\n        operator = /^[+\\-*&%=<>!?|~^]/,\n        sign = /^[:\\[\\(\\{]/,\n        atom = [\"true\", \"false\", \"null\", \"empty\", \"defined\", \"divisibleby\", \"divisible by\", \"even\", \"odd\", \"iterable\", \"sameas\", \"same as\"],\n        number = /^(\\d[+\\-\\*\\/])?\\d+(\\.\\d+)?/;\n    keywords = new RegExp(\"((\" + keywords.join(\")|(\") + \"))\\\\b\");\n    atom = new RegExp(\"((\" + atom.join(\")|(\") + \"))\\\\b\");\n\n    function tokenBase(stream, state) {\n      var ch = stream.peek(); //Comment\n\n      if (state.incomment) {\n        if (!stream.skipTo(\"#}\")) {\n          stream.skipToEnd();\n        } else {\n          stream.eatWhile(/\\#|}/);\n          state.incomment = false;\n        }\n\n        return \"comment\"; //Tag\n      } else if (state.intag) {\n        //After operator\n        if (state.operator) {\n          state.operator = false;\n\n          if (stream.match(atom)) {\n            return \"atom\";\n          }\n\n          if (stream.match(number)) {\n            return \"number\";\n          }\n        } //After sign\n\n\n        if (state.sign) {\n          state.sign = false;\n\n          if (stream.match(atom)) {\n            return \"atom\";\n          }\n\n          if (stream.match(number)) {\n            return \"number\";\n          }\n        }\n\n        if (state.instring) {\n          if (ch == state.instring) {\n            state.instring = false;\n          }\n\n          stream.next();\n          return \"string\";\n        } else if (ch == \"'\" || ch == '\"') {\n          state.instring = ch;\n          stream.next();\n          return \"string\";\n        } else if (stream.match(state.intag + \"}\") || stream.eat(\"-\") && stream.match(state.intag + \"}\")) {\n          state.intag = false;\n          return \"tag\";\n        } else if (stream.match(operator)) {\n          state.operator = true;\n          return \"operator\";\n        } else if (stream.match(sign)) {\n          state.sign = true;\n        } else {\n          if (stream.eat(\" \") || stream.sol()) {\n            if (stream.match(keywords)) {\n              return \"keyword\";\n            }\n\n            if (stream.match(atom)) {\n              return \"atom\";\n            }\n\n            if (stream.match(number)) {\n              return \"number\";\n            }\n\n            if (stream.sol()) {\n              stream.next();\n            }\n          } else {\n            stream.next();\n          }\n        }\n\n        return \"variable\";\n      } else if (stream.eat(\"{\")) {\n        if (stream.eat(\"#\")) {\n          state.incomment = true;\n\n          if (!stream.skipTo(\"#}\")) {\n            stream.skipToEnd();\n          } else {\n            stream.eatWhile(/\\#|}/);\n            state.incomment = false;\n          }\n\n          return \"comment\"; //Open tag\n        } else if (ch = stream.eat(/\\{|%/)) {\n          //Cache close tag\n          state.intag = ch;\n\n          if (ch == \"{\") {\n            state.intag = \"}\";\n          }\n\n          stream.eat(\"-\");\n          return \"tag\";\n        }\n      }\n\n      stream.next();\n    }\n\n    ;\n    return {\n      startState: function startState() {\n        return {};\n      },\n      token: function token(stream, state) {\n        return tokenBase(stream, state);\n      }\n    };\n  });\n  CodeMirror.defineMode(\"twig\", function (config, parserConfig) {\n    var twigInner = CodeMirror.getMode(config, \"twig:inner\");\n    if (!parserConfig || !parserConfig.base) return twigInner;\n    return CodeMirror.multiplexingMode(CodeMirror.getMode(config, parserConfig.base), {\n      open: /\\{[{#%]/,\n      close: /[}#%]\\}/,\n      mode: twigInner,\n      parseDelimiters: true\n    });\n  });\n  CodeMirror.defineMIME(\"text/x-twig\", \"twig\");\n});","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.multiplexingMode = function (outer\n  /*, others */\n  ) {\n    // Others should be {open, close, mode [, delimStyle] [, innerStyle] [, parseDelimiters]} objects\n    var others = Array.prototype.slice.call(arguments, 1);\n\n    function indexOf(string, pattern, from, returnEnd) {\n      if (typeof pattern == \"string\") {\n        var found = string.indexOf(pattern, from);\n        return returnEnd && found > -1 ? found + pattern.length : found;\n      }\n\n      var m = pattern.exec(from ? string.slice(from) : string);\n      return m ? m.index + from + (returnEnd ? m[0].length : 0) : -1;\n    }\n\n    return {\n      startState: function startState() {\n        return {\n          outer: CodeMirror.startState(outer),\n          innerActive: null,\n          inner: null,\n          startingInner: false\n        };\n      },\n      copyState: function copyState(state) {\n        return {\n          outer: CodeMirror.copyState(outer, state.outer),\n          innerActive: state.innerActive,\n          inner: state.innerActive && CodeMirror.copyState(state.innerActive.mode, state.inner),\n          startingInner: state.startingInner\n        };\n      },\n      token: function token(stream, state) {\n        if (!state.innerActive) {\n          var cutOff = Infinity,\n              oldContent = stream.string;\n\n          for (var i = 0; i < others.length; ++i) {\n            var other = others[i];\n            var found = indexOf(oldContent, other.open, stream.pos);\n\n            if (found == stream.pos) {\n              if (!other.parseDelimiters) stream.match(other.open);\n              state.startingInner = !!other.parseDelimiters;\n              state.innerActive = other; // Get the outer indent, making sure to handle CodeMirror.Pass\n\n              var outerIndent = 0;\n\n              if (outer.indent) {\n                var possibleOuterIndent = outer.indent(state.outer, \"\", \"\");\n                if (possibleOuterIndent !== CodeMirror.Pass) outerIndent = possibleOuterIndent;\n              }\n\n              state.inner = CodeMirror.startState(other.mode, outerIndent);\n              return other.delimStyle && other.delimStyle + \" \" + other.delimStyle + \"-open\";\n            } else if (found != -1 && found < cutOff) {\n              cutOff = found;\n            }\n          }\n\n          if (cutOff != Infinity) stream.string = oldContent.slice(0, cutOff);\n          var outerToken = outer.token(stream, state.outer);\n          if (cutOff != Infinity) stream.string = oldContent;\n          return outerToken;\n        } else {\n          var curInner = state.innerActive,\n              oldContent = stream.string;\n\n          if (!curInner.close && stream.sol()) {\n            state.innerActive = state.inner = null;\n            return this.token(stream, state);\n          }\n\n          var found = curInner.close && !state.startingInner ? indexOf(oldContent, curInner.close, stream.pos, curInner.parseDelimiters) : -1;\n\n          if (found == stream.pos && !curInner.parseDelimiters) {\n            stream.match(curInner.close);\n            state.innerActive = state.inner = null;\n            return curInner.delimStyle && curInner.delimStyle + \" \" + curInner.delimStyle + \"-close\";\n          }\n\n          if (found > -1) stream.string = oldContent.slice(0, found);\n          var innerToken = curInner.mode.token(stream, state.inner);\n          if (found > -1) stream.string = oldContent;else if (stream.pos > stream.start) state.startingInner = false;\n          if (found == stream.pos && curInner.parseDelimiters) state.innerActive = state.inner = null;\n\n          if (curInner.innerStyle) {\n            if (innerToken) innerToken = innerToken + \" \" + curInner.innerStyle;else innerToken = curInner.innerStyle;\n          }\n\n          return innerToken;\n        }\n      },\n      indent: function indent(state, textAfter, line) {\n        var mode = state.innerActive ? state.innerActive.mode : outer;\n        if (!mode.indent) return CodeMirror.Pass;\n        return mode.indent(state.innerActive ? state.inner : state.outer, textAfter, line);\n      },\n      blankLine: function blankLine(state) {\n        var mode = state.innerActive ? state.innerActive.mode : outer;\n\n        if (mode.blankLine) {\n          mode.blankLine(state.innerActive ? state.inner : state.outer);\n        }\n\n        if (!state.innerActive) {\n          for (var i = 0; i < others.length; ++i) {\n            var other = others[i];\n\n            if (other.open === \"\\n\") {\n              state.innerActive = other;\n              state.inner = CodeMirror.startState(other.mode, mode.indent ? mode.indent(state.outer, \"\", \"\") : 0);\n            }\n          }\n        } else if (state.innerActive.close === \"\\n\") {\n          state.innerActive = state.inner = null;\n        }\n      },\n      electricChars: outer.electricChars,\n      innerMode: function innerMode(state) {\n        return state.inner ? {\n          state: state.inner,\n          mode: state.innerActive.mode\n        } : {\n          state: state.outer,\n          mode: outer\n        };\n      }\n    };\n  };\n});"],"sourceRoot":""}